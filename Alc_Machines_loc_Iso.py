import xml.etree.ElementTree as ET
import pandas as pd
import os
from tqdm import tqdm  # Import tqdm for progress visualization
from collections import deque

##########
##########
##########
##########



###############------ CHANGE THIS ------###############
input_file_1 = r"D:\chnge order\FLISR\SERVICE ENGINE\ARAR\SLD_TURIF_OFFICE\RT\FILES\zenon\system\alc.XML"
output_folder = r"D:\Zenon py\Line follower\FLISR\outputs"
###############------ CHANGE THIS ------###############

# Load the ID to sub_dest and Smart mapping from the Excel generated by Extract_var.py
subdest_df = pd.read_excel(r"{}\scr_machine_var.xlsx".format(output_folder))
output_file_4 = r"{}\alc_DB_FLIS.xlsx".format(output_folder)


print("="*40)
print("  Extracting Machine Connections and Isolations Script")
print("="*40)

# List of prefixes to ignore
ignore_prefixes = [
    
    "INTEGRATION_PROJECT_NON_SMT_SECTIONALIZER",
    "INTEGRATION_PROJECT_NON_SMT_AUTO_RECLOSER",
    "INTEGRATION_PROJECT_NON_SMT_SLD_LBS",
    # "INTEGRATION_PROJECT_SMT_SECTIONALIZER",
    # "INTEGRATION_PROJECT_SMT_AUTO_RECLOSER",
    # "INTEGRATION_PROJECT_SMT_SLD_LBS",

    "INTEGRATION_PROJECT_NON_SMART_SECTIONALIZER",
    "INTEGRATION_PROJECT_NON_SMART_AUTO_RECLOSER",
    "INTEGRATION_PROJECT_NON_SMART_SLD_LBS",
    # "INTEGRATION_PROJECT_SMART_AUTO_RECLOSER",
    # "INTEGRATION_PROJECT_SMART_SECTIONALIZER",
    # "INTEGRATION_PROJECT_SMART_SLD_LBS",

    "INTEGRATION_PROJECT_SLD_FDR_DSS_1_SEC",
    "INTEGRATION_PROJECT_OH_TRANSFORMER",
    "INTEGRATION_PROJECT_SMART_VOLTAGE",
    "INTEGRATION_PROJECT_NON_SMART_CB",
    "INTEGRATION_PROJECT_SMART_RMU_CB",
    "INTEGRATION_PROJECT_TRANSFORMER",
    "INTEGRATION_PROJECT_Graph_fuse",
    "INTEGRATION_PROJECT_Capacitor",
    "INTEGRATION_PROJECT_SMART_CB",
    "INTEGRATION_PROJECT_NON_ALC",
    "INTEGRATION_PROJECT_PACKEG",
    "INTEGRATION_PROJECT_METER",
    "INTEGRATION_PROJECT_ALARM",
    "INTEGRATION_PROJECT_GRAPH",
    "INTEGRATION_PROJECT_CABLE",
    "INTEGRATION_PROJECT_FUSE",
    "1ELBO_1F_1L_2L_2ELBO_NON",
    "2ELBO_2F_2L_2L_2ELBO_NON",
    "INTEGRATION_PROJECT_UG",
    "Faultcable_button",
    "Combined element",
    "SLD_TERMINATOR",
    "Element group",
    "Info_button",
    "1ELBO_1FUSE",
    "Static text",
    "TERMINATOR",
    "JMP_button",
    "ING_OH_PMT",
    "SLD_SOURCE",
    "Rectangle",
    "LINK_SLD",
    "ALC_LBS",
    "Static",
    "ALC_CB",
    "OH_PMT",
    "1FUSE",
    "Line",
    "CB"
]

special_prefixes = [
    "INTEGRATION_PROJECT_SLD_FDR",
    # "INTEGRATION_PROJECT_NON_SMT_SECTIONALIZER",
    # "INTEGRATION_PROJECT_NON_SMT_AUTO_RECLOSER",
    # "INTEGRATION_PROJECT_NON_SMT_SLD_LBS",
    "INTEGRATION_PROJECT_SMT_SECTIONALIZER",
    "INTEGRATION_PROJECT_SMT_AUTO_RECLOSER",
    "INTEGRATION_PROJECT_SMT_SLD_LBS",

    # "INTEGRATION_PROJECT_NON_SMART_SECTIONALIZER",
    # "INTEGRATION_PROJECT_NON_SMART_AUTO_RECLOSER",
    # "INTEGRATION_PROJECT_NON_SMART_SLD_LBS",
    "INTEGRATION_PROJECT_SMART_SECTIONALIZER",
    "INTEGRATION_PROJECT_SMART_AUTO_RECLOSER",
    "INTEGRATION_PROJECT_SMART_SLD_LBS"
]



# Parse the XML file
tree = ET.parse(input_file_1)
root = tree.getroot()

# Preload all GraphElements into a dictionary for faster lookup
graph_elements_dict = {}
for graph_element in root.findall(".//GraphElement"):
    element_id = graph_element.find("ID").text if graph_element.find("ID") is not None else None
    element_ref = graph_element.find("ElementRef").text if graph_element.find("ElementRef") is not None else None
    if element_id and element_ref:
        graph_elements_dict[element_id] = element_ref

# Function to find the ElementRefName for a given Node ID
def find_machine_name(node_id):
    element_ref = graph_elements_dict.get(node_id)
    if element_ref:
        parts = element_ref.split(".")
        if len(parts) > 1:
            return parts[1]  # Extract the portion after the first period and before the next
    return "Unknown"  # Return "Unknown" if no match is found

# Function to find the ElementRefName for a given Node ID
def find_machine_line_name(node_id):
    element_ref = graph_elements_dict.get(node_id)
    if element_ref:
        parts = element_ref.split(".")
        if len(parts) > 1:
            return parts[2]  # Extract the portion after the second period and before the next
    return "Unknown"  # Return "Unknown" if no match is found

# Group GraphElements by Picture
data_by_picture = {}
graph_elements = root.findall(".//GraphElement")
for graph_element in tqdm(graph_elements, desc="Grouping by Picture"):
    picture = graph_element.find("Picture").text if graph_element.find("Picture") is not None else "Unknown_Picture"
    if picture not in data_by_picture:
        data_by_picture[picture] = []
    data_by_picture[picture].append(graph_element)

# Consolidate all data into a single list
consolidated_data = []

# Helper: Build a mapping from ElementID to GraphElement for traversal
elementid_to_graph_element = {}
for graph_element in graph_elements:
    ID = graph_element.find("ID").text if graph_element.find("ID") is not None else None
    if ID:
        elementid_to_graph_element[ID] = graph_element


def find_variable_for_machine(picture, machine_id):
    """Find all variables for a given machine by searching by picture and (machine_id in elementRef) in xml."""
    for _picture, elements in data_by_picture.items():
        if _picture != picture:
            continue
        for graph_element in elements:
            ID = graph_element.find("ID").text if graph_element.find("ID") is not None else None
            element_id = graph_element.find("ElementID").text if graph_element.find("ElementID") is not None else None
            element_ref = graph_element.find("ElementRef").text if graph_element.find("ElementRef") is not None else None
            element_type = graph_element.find("Type").text if graph_element.find("Type") is not None else None
            # Extract ElementRefName
            element_ref_name = None
            if element_ref:
                parts = element_ref.split(".")
                if len(parts) > 0:
                    element_ref_name = parts[1]  # Extract the portion after the first period and before the next

            if element_ref_name == machine_id and _picture == picture and (element_type == "2" or element_type == "7"):
                variable = graph_element.find("Variable").text if graph_element.find("Variable") is not None else "-"
                if variable != "<No variable linked>" and (variable.endswith("OC_ST") or "FDR" in element_ref_name):
                    return variable
    return "variable not found"

# Helper: Find variable by traversing connections
def find_variable(node_id, element_id, ref):
    graph_element = elementid_to_graph_element.get(node_id)
    if graph_element is None:
        return "ID Not found"
    element_ref = graph_element.find("ElementRef").text if graph_element.find("ElementRef") is not None else None
    variable = graph_element.find("Variable").text if graph_element.find("Variable") is not None else "-"
    parts_ = element_ref.split(".")
    if any(parts_[1].startswith(prefix) for prefix in ignore_prefixes):
        return parts_[1] # "Ignored"
    if any(parts_[1].startswith(prefix) for prefix in special_prefixes) and variable != "<No variable linked>":
        return variable + ">" + parts_[1]
    visited = set()
    visited.add(element_id)
    stack = [node_id]
    element_ref = "***"
    counter = 0
    while stack and parts_[1] in ref: # and parts[1] not in ignore_prefixes
        if counter > 100:  # Prevent infinite loops
            # print(f"Warning: Infinite loop detected for ElementID {element_id} with Node ID {node_id}. Stopping traversal.")
            return parts_[1] if parts_ else "variable not found"
        counter += 1
        current_id = stack.pop()
        if current_id in visited:
            continue
        visited.add(current_id)
        graph_element = elementid_to_graph_element.get(current_id)
        if graph_element is None:
            element_ref = "ID Not found"
            continue
        element_ref = graph_element.find("ElementRef").text if graph_element.find("ElementRef") is not None else None
        variable = graph_element.find("Variable").text if graph_element.find("Variable") is not None else "-"
        if element_ref:
            parts = element_ref.split(".")
            # if any(parts[1].startswith(prefix) for prefix in ignore_prefixes):
            #     return "Ignored"
            if any(parts[1].startswith(prefix) for prefix in special_prefixes) and variable != "<No variable linked>":
                return variable + ">" + parts[1]
            if len(parts) >3:
                if parts[2].startswith("INTEGRATION_PROJECT_ALC_ES") and parts[3] == "DC" and variable != "<No variable linked>":
                    return variable + ">" + parts[1]
            if len(parts) >2:
                if parts[2] == "ALC_LBS" and variable != "<No variable linked>":
                    return variable + ">" + parts[1]
            # if (
            #     ("#" not in variable or
            #     "." not in variable ) and
            #     any(y in variable for y in ["Y1", "Y2", "Y3", "Y4", "Y5", "Y6"])
            # ):
                
        # Traverse further connections
        next_node1_ids = [n.text for n in graph_element.findall(".//Node1IDs/ID")]
        next_node2_ids = [n.text for n in graph_element.findall(".//Node2IDs/ID")]
        stack.extend(next_node1_ids + next_node2_ids)
    return parts_[1] if parts_ else "variable not found"

for picture, elements in tqdm(data_by_picture.items(), desc="Processing Pictures"):
    if "EMERGENCY" in str(picture).upper() or "EMRGENCY" in str(picture).upper():
        continue
    for graph_element in elements:
        ID = graph_element.find("ID").text if graph_element.find("ID") is not None else None
        element_id = graph_element.find("ElementID").text if graph_element.find("ElementID") is not None else None
        element_ref = graph_element.find("ElementRef").text if graph_element.find("ElementRef") is not None else None
        element_type = graph_element.find("Type").text if graph_element.find("Type") is not None else None

        # Extract ElementRefName
        element_ref_name = None
        parts = []
        parts_2 = None
        if element_ref:
            parts = element_ref.split(".")
            if len(parts) > 0:
                element_ref_name = parts[1]  # Extract the portion after the first period and before the next
        if element_ref_name.startswith("INTEGRATION_PROJECT_CABLE_RISER"):
            element_ref_name = parts[2] + "_" + element_ref_name
        
        # Extract Node1 and Node2 IDs
        node1_ids = [node.text for node in graph_element.findall(".//Node1IDs/ID")]
        node2_ids = [node.text for node in graph_element.findall(".//Node2IDs/ID")]

        # Resolve Node IDs to connections by searching for the corresponding ID in the preloaded dictionary
        node1_connections = [find_machine_name(node_id) for node_id in node1_ids]
        node2_connections = [find_machine_name(node_id) for node_id in node2_ids]

        for i, node1_connection in enumerate(node1_connections):
            if node1_connection.startswith("INTEGRATION_PROJECT_CABLE_RISER"):
                node1_connections[i] = find_machine_line_name(node1_ids[i]) + "_" + node1_connection
                # node1_ids[i] = node1_connection
        for i, node2_connection in enumerate(node2_connections):
            if node2_connection.startswith("INTEGRATION_PROJECT_CABLE_RISER"):
                node2_connections[i] = find_machine_line_name(node2_ids[i]) + "_" + node2_connection
                # node2_ids[i] = node2_connection

        # Find Node1 and Node2 Variables
        # node1_variables = [find_variable(node_id, ID, node1_connections) for node_id in node1_ids]
        # node2_variables = [find_variable(node_id, ID, node2_connections) for node_id in node2_ids]

        # Check if the element is a line or bridge
        if element_type == "128" and element_id and int(element_id) < 9999999:
            # Line
            consolidated_data.append({
                "Picture": picture,
                "LineRefName": ID +">"+ element_ref_name,
                "Node1 connections": ", ".join([node1_ids[i] +">"+ node1_connections[i] for i in range(len(node1_ids)) if node1_connections[i]]),
                "Node2 connections": ", ".join([node2_ids[i] +">"+ node2_connections[i] for i in range(len(node2_ids)) if node2_connections[i]]),
                # "Node1 Variables": ", ".join([v for v in node1_variables if v]),
                # "Node2 Variables": ", ".join([v for v in node2_variables if v])
            })
        elif element_type == "2" and element_ref and element_ref_name.startswith("ALC_LBS") and not element_ref_name.startswith(("ALC_LBS_LEFT", "ALC_LBS_RIGHT")):
            # Bridge
            consolidated_data.append({
                "Picture": picture,
                "LineRefName": ID +">"+ element_ref_name,
                "Node1 connections": ", ".join([node1_ids[i] +">"+ node1_connections[i] for i in range(len(node1_ids)) if node1_connections[i]]),
                "Node2 connections": ", ".join([node2_ids[i] +">"+ node2_connections[i] for i in range(len(node2_ids)) if node2_connections[i]]),
                # "Node1 Variables": ", ".join([v for v in node1_variables if v]),
                # "Node2 Variables": ", ".join([v for v in node2_variables if v])
            })
        elif element_type == "128" and element_id and "INTEGRATION_PROJECT_CABLE_RISER" in element_ref_name:
            # Line
            consolidated_data.append({
                "Picture": picture,
                "LineRefName": ID +">"+ element_ref_name,
                "Node1 connections": ", ".join([node1_ids[i] +">"+ node1_connections[i] for i in range(len(node1_ids)) if node1_connections[i]]),
                "Node2 connections": ", ".join([node2_ids[i] +">"+ node2_connections[i] for i in range(len(node2_ids)) if node2_connections[i]]),
                # "Node1 Variables": ", ".join([v for v in node1_variables if v]),
                # "Node2 Variables": ", ".join([v for v in node2_variables if v])
            })

            

# Export the consolidated data to a single Excel file
output_file_1 = r"{}\alc_Consolidated_Var.xlsx".format(output_folder)
df = pd.DataFrame(consolidated_data)
df.to_excel(output_file_1, index=False)
print(f"Consolidated data exported to {output_file_1}")


############################################################



# Build mapping with (Picture, ID) as key
id_to_subdest = {}
id_to_smart = {}
id_to_visualname = {}
id_to_FeederNo = {}

for _, row in subdest_df.iterrows():
    key = (row["ScreenName"], str(row["ID"]))
    id_to_subdest[key] = row["Variable"]
    id_to_smart[key] = row["SMART"]
    id_to_visualname[key] = row["VisualName"]
    id_to_FeederNo[key] = row["FeederNo"]

# Load the consolidated data from the existing Excel file
input_file_2 = r"{}\alc_Consolidated_Var.xlsx".format(output_folder)
df = pd.read_excel(input_file_2)

# Helper function to check if an item is a machine
def is_machine(item):
    parts_ = item.split(">")
    if len(parts_) < 2:
        return not any(item.startswith(prefix) for prefix in ignore_prefixes)
    return not any(parts_[1].startswith(prefix) for prefix in ignore_prefixes)


# Helper function to check if an item is a special machine (traversal should stop at these)
def is_special(item):
    parts_ = item.split(">")
    if len(parts_) < 2:
        name = item
    else:
        name = parts_[1]
    return any(name.startswith(prefix) for prefix in special_prefixes)


# Final output list
final_output = []

# Process each picture group separately
for picture, picture_df in df.groupby("Picture"):
    if "EMERGENCY" in str(picture).upper() or "EMRGENCY" in str(picture).upper():
        continue
    # Create a dictionary to store connections for each element
    connections = {}

    # Build the connections dictionary
    for _, row in picture_df.iterrows():
        line_ref = row["LineRefName"] if pd.notna(row["LineRefName"]) else None
        node1_connections = str(row["Node1 connections"]).split(", ") if pd.notna(row["Node1 connections"]) else []
        node2_connections = str(row["Node2 connections"]).split(", ") if pd.notna(row["Node2 connections"]) else []

        # Add connections for Node1
        for node1 in node1_connections:
            if (picture, node1) not in connections:
                connections[(picture, node1)] = set()
            if line_ref:
                connections[(picture, node1)].add((picture, line_ref))
            if line_ref and (picture, line_ref) not in connections:
                connections[(picture, line_ref)] = set()
            if line_ref:
                connections[(picture, line_ref)].update((picture, n2) for n2 in node2_connections)

        # Add connections for Node2
        for node2 in node2_connections:
            if (picture, node2) not in connections:
                connections[(picture, node2)] = set()
            if line_ref:
                connections[(picture, node2)].add((picture, line_ref))
            if line_ref and (picture, line_ref) not in connections:
                connections[(picture, line_ref)] = set()
            if line_ref:
                connections[(picture, line_ref)].update((picture, n1) for n1 in node1_connections)


    # Iterative function to find all connected machines (prevents recursion issues)
    def find_connected_machines(start_machine, visited=None):
        if visited is None:
            visited = set()
        
        connected_machines = set()
        stack = [start_machine]
        
        while stack:
            current = stack.pop()
            if current in visited:
                continue
            visited.add(current)
            
            for neighbor in connections.get(current, []):
                pic, nid = neighbor
                if neighbor not in visited:
                    if is_machine(nid):  # Pass only the ID
                        connected_machines.add(nid)
                        # remove its neighbors ###############################@@@
                        for neighbor_1 in connections.get(neighbor, []):
                            if neighbor_1 not in visited:
                                visited.add(neighbor_1)
                        continue
                    # # Do not traverse past special machines; include them but stop there
                    # if is_special(nid):
                    #     continue

                    if "NOP" in nid:
                        continue

                    # Only traverse through non-machine elements (lines/connectors)
                    stack.append(neighbor)
        
        return connected_machines

    # Find connections for each machine
    machine_connections = {}
    for machine in connections:
        if is_machine(machine[1]):  # Use the ID part of the tuple
            machine_connections[machine[1]] = find_connected_machines(machine)

    # Prepare the data for this picture
    for machine, connected_machines in machine_connections.items():
        machine_ = machine.split(">")
        row = [picture, machine_[1]] + list(connected_machines)[:14]  # Limit to 14 connections
        row += [""] * (16 - len(row))  # Pad with empty strings to 16 columns total
        # Do not append if the machine is FDR
        if "FDR" not in machine:
            final_output.append(row)    
        # final_output.append(row)    # Uncomment to include FDR machines

# Create a DataFrame for the output
output_columns = ["Picture", "Machine", "Con1", "Con2", "Con3", "Con4", "Con5", "Con6", "Con7", "Con8", "Con9", "Con10", "Con11", "Con12", "Con13", "Con14"]
output_df = pd.DataFrame(final_output, columns=output_columns)

# Replace Machine and Con1-Con14 if they match an ID in the mapping for the current Picture
def map_id_to_subdest(picture, id_val):
    return id_to_subdest.get((picture, str(id_val)), id_val)

def map_id_to_smart(picture, id_val):
    return id_to_smart.get((picture, str(id_val)), "-")

def map_id_to_visualname(picture, id_val):
    return id_to_visualname.get((picture, str(id_val)), "-")


def map_id_to_FeederNo(picture, id_val):
    return id_to_FeederNo.get((picture, str(id_val)), "-")

# Apply mapping for each row
def process_row(row):
    picture = row["Picture"]
    machine_id = row["Machine"]
    machine = map_id_to_subdest(picture, machine_id)
    smart = map_id_to_smart(picture, machine_id)
    visualname = map_id_to_visualname(picture, machine_id)
    connections_name = [map_id_to_subdest(picture, row.get(f"Con{i}", "-")) for i in range(1, 15)]
    # Pad connections_name to 14 items
    connections_name += ["-"] * (14 - len(connections_name))
    return [picture, machine_id, machine, visualname, smart] + connections_name

output_df = pd.DataFrame([process_row(row) for _, row in output_df.iterrows()],
                         columns=["Picture", "ID", "Machine", "VisualName", "SMART", "Con1", "Con2", "Con3", "Con4", "Con5", "Con6", "Con7", "Con8", "Con9", "Con10", "Con11", "Con12", "Con13", "Con14"])
# Remove duplicates based on Picture and ID
# output_df.drop_duplicates(subset=["Picture", "ID"], inplace=True)

# Replace empty cells with a dash
output_df.fillna("-", inplace=True)
output_df.replace("", "-", inplace=True)

# Export the new data to an Excel file
output_file_2 = r"{}\machine_connections_alone.xlsx".format(output_folder)
output_df.to_excel(output_file_2, index=False)
print(f"Machine-to-machine connections exported to {output_file_2}")


######################################################################
######################################################################
######################################################################


# for every ID in the output_df, find the connections in the machine_connections_alone data
machine_connections_df = pd.read_excel(r"{}\machine_connections_alone.xlsx".format(output_folder))

# Build mapping with (Picture, ID) as key
connections_mapping = {}
for _, row in machine_connections_df.iterrows():
    key = (row["Picture"], str(row["ID"]))
    if key not in connections_mapping:
        connections_mapping[key] = []
    for i in range(1, 15):
        if pd.notna(row[f"Con{i}"]) and row[f"Con{i}"] != "-":
            if row[f"Con{i}"] not in connections_mapping[key]:
                connections_mapping[key].append(row[f"Con{i}"])

# Prepare the final output DataFrame
final_output = []
for _, row in tqdm(output_df.iterrows(), total=output_df.shape[0], desc="Processing connections"):
    picture = row["Picture"]
    if "EMERGENCY" in str(picture).upper() or "EMRGENCY" in str(picture).upper():
        continue
    machine = str(row["ID"])  # Use as "Machine" column
    key = (picture, machine)
    connections = connections_mapping.get(key, [])
    final_row = [picture, machine] + connections[:14]
    final_row += [""] * (16 - len(final_row))  # Ensure 16 columns
    if "FDR" not in machine:
        final_output.append(final_row)
    # final_output.append(final_row)

# Create a DataFrame for the output
output_columns = ["Picture", "Machine", "Con1", "Con2", "Con3", "Con4", "Con5", "Con6", "Con7", "Con8", "Con9", "Con10", "Con11", "Con12", "Con13", "Con14"]
output_df_1 = pd.DataFrame(final_output, columns=output_columns)

output_df_1 = pd.DataFrame([process_row(row) for _, row in output_df_1.iterrows()],
                         columns=["Picture", "ID", "Machine", "VisualName", "SMART", "Con1", "Con2", "Con3", "Con4", "Con5", "Con6", "Con7", "Con8", "Con9", "Con10", "Con11", "Con12", "Con13", "Con14"])

# Remove duplicates based on Picture and ID
output_df_1.drop_duplicates(subset=["Picture", "ID"], inplace=True)
# Replace empty cells with a dash
output_df_1.fillna("-", inplace=True)
output_df_1.replace("", "-", inplace=True)

# Export the new data to an Excel file
output_file_3 = r"{}\machine_connections_iso.xlsx".format(output_folder)
output_df_1.to_excel(output_file_3, index=False)
print(f"Machine-to-machine connections exported to {output_file_3}")


############################################################
# This script builds a connections dictionary for all pictures and finds SMART machines from each machine.
# It then adds columns for smart machines (smart1 to smart7) to the output Data
############################################################

def find_all_variables_for_machine(picture, machine_id):
    """Find all variables for a given machine by searching by picture and (machine_id in elementRef) in xml."""
    variables = []
    for _picture, elements in data_by_picture.items():
        if _picture != picture:
            continue
        for graph_element in elements:
            ID = graph_element.find("ID").text if graph_element.find("ID") is not None else None
            element_id = graph_element.find("ElementID").text if graph_element.find("ElementID") is not None else None
            element_ref = graph_element.find("ElementRef").text if graph_element.find("ElementRef") is not None else None
            element_type = graph_element.find("Type").text if graph_element.find("Type") is not None else None
            # Extract ElementRefName
            element_ref_name = None
            if element_ref:
                parts = element_ref.split(".")
                if len(parts) > 0:
                    element_ref_name = parts[1]  # Extract the portion after the first period and before the next

            if element_ref_name == machine_id and _picture == picture and element_type == "2":
                variable = graph_element.find("Variable").text if graph_element.find("Variable") is not None else "-"
                if variable != "<No variable linked>" and variable.endswith("OC_ST") or variable.endswith("GND_ST"):
                    variables.append(variable)
    return variables
                
            
# Helper: Find variable by traversing connections
def find_variable_stand_alone(element_id):
    graph_element = elementid_to_graph_element.get(element_id)
    if graph_element is None:
        return "Element Not found!" + ">" + parts_[1]
    element_ref = graph_element.find("ElementRef").text if graph_element.find("ElementRef") is not None else None
    variable = graph_element.find("Variable").text if graph_element.find("Variable") is not None else "-"
    parts_ = element_ref.split(".")

    if any(parts_[1].startswith(prefix) for prefix in ignore_prefixes):
        return "Ignored!" + ">" + parts_[1] # "Ignored"
    if any(parts_[1].startswith(prefix) for prefix in special_prefixes) and variable != "<No variable linked>":
        return variable + ">" + parts_[1]

    if len(parts_) >3:
        if parts_[2].startswith("INTEGRATION_PROJECT_ALC_ES") and parts_[3] == "DC" and variable != "<No variable linked>":
            return variable + ">" + parts_[1]
    if len(parts_) >3:
        if parts_[2].startswith("ALC_LBS") and variable != "<No variable linked>":
            return variable + ">" + parts_[1]
    
    visited = set()
    stack = [element_id]
    counter = 0
    while stack: # and parts[1] not in ignore_prefixes
        if counter > 50000:  # Prevent infinite loops
            return "Infinite loop detected!" + ">" + parts_[1]
        counter += 1
        current_id = stack.pop()
        if current_id in visited:
            continue
        visited.add(current_id)
        graph_element = elementid_to_graph_element.get(current_id)
        if graph_element is None:
            element_ref = "ID Not found"
            continue
        element_ref = graph_element.find("ElementRef").text if graph_element.find("ElementRef") is not None else None
        variable = graph_element.find("Variable").text if graph_element.find("Variable") is not None else "-"
        element_type = graph_element.find("Type").text if graph_element.find("Type") is not None else None
        parts = element_ref.split(".")
        
        if element_ref and parts[1] == parts_[1]:
            if any(parts[1].startswith(prefix) for prefix in special_prefixes) and variable != "<No variable linked>":
                return variable + ">" + parts[1]
            if len(parts) >3:
                if parts[2].startswith("ALC_LBS") and variable != "<No variable linked>":
                    return variable + ">" + parts[1]
            if element_type in ["2", "7"]:
                variable = graph_element.find("Variable").text if graph_element.find("Variable") is not None else "-"
                if variable != "<No variable linked>" and variable.endswith("OC_ST"):
                    return variable + ">" + parts_[1]
        else:
            continue
        # Traverse further connections
        next_node1_ids = [n.text for n in graph_element.findall(".//Node1IDs/ID")]
        next_node2_ids = [n.text for n in graph_element.findall(".//Node2IDs/ID")]
        stack.extend(next_node1_ids + next_node2_ids)
    return "variable not found!" + ">" + parts_[1]



def is_smart(picture, id_val):
    machine_ = id_val.split(">")
    if len(machine_)  > 1:
        return id_to_smart.get((picture, str(machine_[1])), "not SMART") == "SMART"
    return id_to_smart.get((picture, str(id_val)), "NON SMART") == "SMART"

# use the connections mapping built previously
all_connections = {}
all_connections_id = {}
for key, connections in connections_mapping.items():
    picture, machine_id = key
    for conn in connections:
        conn_ = conn.split(">")
        if (picture, machine_id) not in all_connections:
            all_connections[(picture, machine_id)] = set()
            all_connections_id[(picture, machine_id)] = set()
        all_connections[(picture, machine_id)].add((picture, conn))
        all_connections_id[(picture, machine_id)].add((picture, conn_[1], conn_[0]))


def find_all_smart_machines_from(picture, machine_id, connections, is_smart, max_count=14, curr_id_0=None):
    """DFS from machine_id, collect first smart machine found on each path (excluding self), up to max_count unique."""
    found = set()
    visited = set()
    queue = deque()
    queue.append((picture, machine_id, curr_id_0))  # Start with the current machine

    while queue and len(found) < max_count:
        pic, curr_1, curr_0 = queue.popleft()
        if (pic, curr_1) in visited:
            continue
        visited.add((pic, curr_1))
        if curr_1 != machine_id and is_smart(pic, curr_1):
            found.add(curr_0)  # Add the smart machine found
            if len(found) >= max_count:
                break
            continue  # Don't go past a smart machine
        for neighbor in connections.get((pic, curr_1), []):
            _pic, _curr_1, _curr_0 = neighbor
            if (_pic, _curr_1) not in visited:
                queue.append(neighbor)
    return list(found)[:max_count]

# Add smart1-smart14 columns to output_df_1
smart_cols = [f"ISO{i}" for i in range(1, 15)]
for col in smart_cols:
    output_df_1[col] = "-"

output_df_1["NOP"] = "-"
output_df_1["NOP_Variables"] = "-"


smart_rec_sec = set([
    "INTEGRATION_PROJECT_NON_SMT_SECTIONALIZER",
    "INTEGRATION_PROJECT_NON_SMT_AUTO_RECLOSER",
    "INTEGRATION_PROJECT_NON_SMART_AUTO_RECLOSER",
    "INTEGRATION_PROJECT_NON_SMART_SECTIONALIZER",
    "INTEGRATION_PROJECT_SMT_SECTIONALIZER",
    "INTEGRATION_PROJECT_SMT_AUTO_RECLOSER",
    "INTEGRATION_PROJECT_SMART_AUTO_RECLOSER",
    "INTEGRATION_PROJECT_SMART_SECTIONALIZER"
])

smart_lbs = set([
    "INTEGRATION_PROJECT_SMT_SLD_LBS",
    "INTEGRATION_PROJECT_SMART_SLD_LBS",
    "INTEGRATION_PROJECT_NON_SMART_SLD_LBS",
    "INTEGRATION_PROJECT_NON_SMT_SLD_LBS",
])


def get_machine_name(elem_id):
    elem = elementid_to_graph_element[elem_id] if elem_id in elementid_to_graph_element else None
    if elem is None:
        return elem_id  # Return ID if element not found
    element_ref = elem.find('ElementRef').text if elem.find('ElementRef') is not None else elem_id
    parts = element_ref.split('.')
    name = parts[1] if len(parts) > 1 else elem_id
    return name

# Use all_connections as built previously
for idx, row in tqdm(output_df_1.iterrows(), total=output_df_1.shape[0], desc="Processing Isolations"):
    picture = row["Picture"]
    machine_id = row["ID"]
    smart_ids = find_all_smart_machines_from(picture, machine_id, all_connections_id, is_smart)
    iso_nums = ""
    for i, smart_id in enumerate(smart_ids):
        # smart_id_0 = all_connections.get((picture, smart_id), [])
        # smart_id_0 = [s[0] for s in smart_id_0]  # Extract just the ID part
        smart_var_id = get_machine_name(smart_id)
        if any(smart_var_id.startswith(prefix) for prefix in special_prefixes):
            # Get variable from id_to_subdest
            smart_var = id_to_subdest.get((picture, smart_var_id), "-")
        else:
            smart_var = find_variable_stand_alone(smart_id)

        if "FDR" in smart_var_id and smart_var != "-": # FDR
            smart_var = smart_var.split("_OC_", 1)[0] if "_OC_" in smart_var else smart_var.split("_CB_IND", 1)[0]
        elif any(smart_var_id.startswith(prefix) for prefix in smart_rec_sec):
            smart_var = smart_var.replace("_OC_ST", "_OPN_CMD")
        elif "#" in smart_var and ("_Y" in smart_var or "_TR_" in smart_var): # SMART rmu
            smart_var = smart_var.split("_OC_", 1)[0]
        else: # use ID
            smart_var = smart_var_id

        output_df_1.at[idx, f"ISO{i+1}"] = smart_var if smart_var else "-"
        
        if "FDR" in smart_var_id:
            eq_num = map_id_to_FeederNo(picture, smart_var_id)
            # print(f"ISO FDR for machine {machine_id}: {eq_num}")
        else:
            eq_num = map_id_to_visualname(picture, smart_var_id)
        
        # Convert eq_num to string and handle NaN values
        eq_num_str = str(eq_num) if pd.notna(eq_num) and eq_num != "-" else "-"
        if eq_num_str != "-":
            iso_nums = iso_nums + eq_num_str + ","
        output_df_1.at[idx, "Isolation Equipments Numbers"] = iso_nums if iso_nums else "-"

        # output_df_1.at[idx, f"ISO{i+1}"] = smart_id if smart_id else "-"

    if "NOP" in machine_id:
        output_df_1.at[idx, "NOP"] = "NOP"
        # find all variables for NOP machines
        nop_vars = find_all_variables_for_machine(picture, machine_id)
        if nop_vars:
            nop_vars_str = ",".join(nop_vars)
            output_df_1.at[idx, "NOP_Variables"] = nop_vars_str

    nop = row["NOP"]
    after_nums = ""
    loc_ids = ""
    for i in range(1, 15):
        con = row[f"Con{i}"]
        if con != "-":
            parts = con.split(">")
            if len(parts) > 1:
                con = parts[1]
            if parts[1] == machine_id:
                output_df_1.at[idx, f"Con{i}"] = "-"
                continue

            # con_var = find_variable_stand_alone(con)
            # parts = con_var.split(">")
            # con_var = parts[0]

            # Get variable from id_to_subdest
            con_var = id_to_subdest.get((picture, parts[1]), "-")
            
            if "FDR" in parts[1] and con_var != "-":
                con_var = con_var.split("_OC_", 1)[0]
                con_var = con_var + "_EF_ST"
            elif any(parts[1].startswith(prefix) for prefix in smart_rec_sec) and "#" in con_var:
                con_var = con_var.split("_OC_", 1)[0]
                con_var = con_var + "_E_FLT"
            elif any(parts[1].startswith(prefix) for prefix in smart_lbs) and "#" in con_var:
                con_var = con_var.split("_OC_", 1)[0]
                con_var = con_var + "_EFI_ST"
            elif any(parts[1].startswith(prefix) for prefix in smart_rec_sec) and "#" not in con_var and con_var != "-":
                con_var = con_var.split("_OC_", 1)[0]
                con_var = con_var + ""
            elif any(parts[1].startswith(prefix) for prefix in smart_lbs) and "#" not in con_var and con_var != "-":
                con_var = con_var.split("_OC_", 1)[0]
                con_var = con_var + ""
            # if "#" in con_var and "_Y" not in con_var and "_TR_" not in con_var and len(con_var) > 22: # FDR
            #     con_var = con_var.split("_OC_", 1)[0]
            #     con_var = con_var + "_EF_ST"
                # con_var = con_var.split("#", 1)[1].split("_OC_", 1)[0]

            # elif "#" in con_var and "_Y" in con_var: # SMRT
            #     con_var = con_var.split("_Y", 1)[0]
            #     con_var = con_var + "_EF_ST"
            # elif "#" in con_var and "_TR_" in con_var: # SMRT
            #     con_var = con_var.split("_TR_", 1)[0]
            #     con_var = con_var + "_EF_ST"
            #     # con_var = con_var.split("#", 1)[1].split("_Y", 1)[0]
            # elif "." in con_var: # OLD
            #     con_var = con_var.split(".", 1)[0]
            #     con_var = con_var + ".EF_ST"
            
            elif "#" in con_var:
                con_var = con_var + "_EF_ST"
            elif con_var != "-":
                con_var = con_var + ".EF_ST"

            else: # use ID
                con_var = parts[1]

            output_df_1.at[idx, f"Con{i}"] = con_var if "***" not in con_var else parts[1]

            # if "FDR" in parts[1]:
            #     eq_num = map_id_to_FeederNo(picture, parts[1])
            # else:
            #     eq_num = map_id_to_visualname(picture, parts[1])
            # # Convert eq_num to string and handle NaN values
            # eq_num_str = str(eq_num) if pd.notna(eq_num) and eq_num != "-" else "-"
            # if i == 1:
            #     output_df_1.at[idx, "Before Equipment Number"] = eq_num_str 
            # else:
            #     if eq_num_str != "-":
            #         after_nums = after_nums + eq_num_str + ","
            #     output_df_1.at[idx, "After Equipment Number"] = after_nums if after_nums else "-"

            eq_id_str = str(parts[1]) if pd.notna(parts[1]) and parts[1] != "-" else "-"
            if eq_id_str != "-":
                loc_ids = loc_ids + eq_id_str + ","
            output_df_1.at[idx, "Location Equipments IDs"] = loc_ids if loc_ids else "-"


            # if "NOP" in row["ID"]:
            #     nop = nop + "," + parts[1]
            #     output_df_1.at[idx, "NOP"] = nop

        machine = row["Machine"] ###########
        if machine != "-":
            if "#" in machine: # SMART
                if any(machine_id.startswith(prefix) for prefix in smart_rec_sec):
                    machine = machine + "_E_FLT"
                elif any(machine_id.startswith(prefix) for prefix in smart_lbs):
                    machine = machine + "_EFI_ST"
                else:
                    machine = machine + "_EF_ST"
            else: # OLD
                if any(parts[1].startswith(prefix) for prefix in smart_rec_sec):
                    machine = machine + ""
                elif any(parts[1].startswith(prefix) for prefix in smart_lbs):
                    machine = machine + ""
                else:
                    machine = machine + ".EF_ST"
            output_df_1.at[idx, "Machine"] = machine

        if "FDR" in machine_id:
            eq_num = map_id_to_FeederNo(picture, machine_id)
            eq_num_str = str(eq_num) if pd.notna(eq_num) and eq_num != "-" else "-"
            output_df_1.at[idx, "VisualName"] = eq_num_str
        
        if row["VisualName"] == "-":
            output_df_1.at[idx, "VisualName"] = row["ID"]


output_df_1.to_excel(output_file_4, index=False)
print(f"Machines Database exported to {output_file_4}")
